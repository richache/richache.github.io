<!DOCTPYE html>
<html>
<head>
	<title>JS函数闭包</title>
	<meta charset="utf-8">
	<style>
		body{
			background-color:#f0f0f0;
			padding:50px 120px 50px 120px;
			margin:20px 30px 20px 30px;
			color:#654315;
			line-height:150%;
		}
		p{
			text-align:justify;
			color:#666;
		}
		h4{
			color:#000;
			text-shadow:1px 1px #999;
		}
		pre{
			font-size:25px;
			color:#852130;
		}
	</style>
	<script>
		document.write("<h1>JS函数闭包</h1>");
		document.write("<h5>2017年9月26日 Powered By-銘東辰</h5><hr/>");
	</script>
</head>
<body>
	<h4>闭包的作用</h4>
	<b>计数器矛盾：</b><br/>
	<p>如果想统计一些数值，且该计数器在所有函数中都是可用的，则可以使用全局变量，函数设置计数器递增：</p>
	<p>在js中声明一个变量count=0为计数器初始值，声明一个函数add()作为累加计数器，然后返回count+=1。</p>
	<p>每一次调用该函数，count就会+1，实现计数器功能。</p><hr/>
	<p>但是在window对象下声明的这个count是全局变量，很容易被修改，我们需要一个函数，声明局部变量，当函数没有被调用时外部不能修改这个变量的值。</p><hr/>
	<p>那么直接把全局变量移到函数内作为局部变量存在，会产生什么问题呢？</p>
	<p>可以料到，该函数每调用一次，输出都是1，这是因为每次调用该函数时都会重新声明初始值并执行一次累加。</p>
	<p>这与目标效果大相径庭。为了声明局部变量，重复自我调用函数实现累加，联想一下，发现可以利用函数嵌套实现。</p><hr/>
	<p>实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。
	<p>该实例中，内嵌函数 plus()可以访问父函数的 count 变量：</p>
	<pre><i>实例:
		function add() {
		var count = 0;
		function plus() {count += 1;}
		plus();    
		return count; 
		}</i></pre>
	<p>如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境。我们同样需要确保 count = 0 只执行一次。为此我们需要闭包。</p><hr/>
	<h4>闭包的概念</h4>
	<p>闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。</p>
	<p>改成以下闭包即可实现函数的自我调用：</p>
	<pre><i>
		var add=(function(){
				var count=0;
				return function(){return count+=1;}
			})();</i></pre>
	<p>变量 add 指定了函数自我调用的返回字值。自我调用函数只执行一次。设置计数器为 0。并返回<ins>函数表达式</ins>（该实例中为返回function(){return count+=1;}）。</p>
	<p>add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。</p>
	<p>这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。计数器受匿名函数的作用域保护，只能通过 add 方法修改。</p>
	<p>效果：</p>
	<button type="button" onclick="document.getElementById('counter').innerHTML=add();">点击累加</button>
	<p id="counter">0</p>
	<script>
			var add=(function(){
				var count=0;
				return function(){return count+=1;}
			})();
	</script>
</body>
</html>